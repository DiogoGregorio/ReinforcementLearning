Quem e o quÃª

Quidgest Ã© uma empresa global de origem portuguesa, com sede em Lisboa. 
Quidgest
+2
Quidgest
+2

EstÃ¡ hÃ¡ mais de 30 anos (fundada em 1988) no mercado de engenharia de software. 
Quidgest
+1

Especializa-se em â€œmodel-driven engineeringâ€ e geraÃ§Ã£o automÃ¡tica de cÃ³digo, sobretudo atravÃ©s da sua plataforma prÃ³pria chamada Genio. 
Quidgest
+2
Quidgest
+2

A empresa trabalha em diversos domÃ­nios de software de gestÃ£o (recursos humanos, finanÃ§as, compliance, logÃ­stica, etc.). 
Quidgest
+1

Cultura, missÃ£o e valores

VisÃ£o: Ser uma referÃªncia como fornecedor de â€œsoftware Ã  medidaâ€ (custom made) e reconhecida pela excelÃªncia. 
Quidgest

MissÃ£o: Criar valor para clientes e parceiros, participar da revoluÃ§Ã£o tecnolÃ³gica, desenvolver competÃªncias nos colaboradores. 
Quidgest

A empresa valoriza inovaÃ§Ã£o, qualidade, participaÃ§Ã£o e desenvolvimento das competÃªncias dos funcionÃ¡rios. 
Quidgest
+1

Tecnologia & plataforma relevante

A plataforma Genio permite gerar software para mÃºltiplas tecnologias: suportando web, mobile, bases de dados, diferentes linguagens. 
Quidgest
+1

Destaca-se por usar modelagem em vez de â€œapenas escrever cÃ³digoâ€, ou seja, abstraÃ§Ã£o mais elevada. 
Quidgest
+1

Tecnologias mencionadas: ASP.NET MVC, C#/.NET, WCF, bases de dados SQL Server, Oracle, MySQL. 
Quidgest

A empresa certifica-se em normas de qualidade (ISO 9001, ISO 27001, etc.). 
Quidgest

RelevÃ¢ncia para a vaga (Software Engineer â€“ RH/Recruitment/Performance Management)

Na Ã¡rea de Recursos Humanos / recrutamento / gestÃ£o de desempenho, vais integrar-te num domÃ­nio de â€œsoftware de gestÃ£oâ€ ou â€œsistemas de informaÃ§Ã£o de gestÃ£oâ€, que Ã© exactamente o core da Quidgest.

Importa mostrares familiaridade ou aptidÃ£o para modelagem, abstraÃ§Ã£o, reutilizaÃ§Ã£o de componentes â€” porque a Genio trabalha nesse espÃ­rito.

TambÃ©m Ã© provÃ¡vel que se valorize o teu entendimento de ciclo de vida do software: desenho, implementaÃ§Ã£o, manutenÃ§Ã£o, evoluÃ§Ã£o â€” nÃ£o apenas â€œescrever cÃ³digoâ€.

Dado que vais entrevistar com o CTO da Ã¡rea de software de RH/recrutamento/gestÃ£o de desempenho, prepara-te para falar de como construir sistemas que suportem workflows de RH: e.g., cadastro de candidatos, entrevistas, avaliaÃ§Ã£o de desempenho, relatÃ³rios, dashboards, integraÃ§Ã£o com bases de dados de colaboradores, etc.

Alguns â€œinputsâ€ para a entrevista tÃ©cnica

Prepara-te para mostrar capacidade para discutir padrÃµes de design (por exemplo para mÃ³dulos de RH: AvaliaÃ§Ã£o, Feedback, HistÃ³rico de Colaboradores, Workflows), arquitetura limpa, manutenÃ§Ã£o e escalabilidade.

Prepara-te para perguntas de lÃ³gica de programaÃ§Ã£o, estruturas de dados e algoritmos â€” embora o foco seja mais â€œsoftware engineeringâ€ do que â€œpuzzle puroâ€.

Prepara-te para falar de integraÃ§Ã£o/compatibilidade/legado â€” jÃ¡ que a Quidgest tem actuaÃ§Ã£o em sistemas legados e atualizaÃ§Ã£o de plataformas obsoletas nas suas soluÃ§Ãµes. 
Quidgest
+1

Assume que te podem perguntar como modelarias entidades para RH, por exemplo â€œColaboradorâ€, â€œAvaliaÃ§Ã£o de desempenhoâ€, â€œFeedbackâ€, â€œPlano de desenvolvimentoâ€, e como o sistema evoluiria no futuro.

Dicas prÃ¡ticas para a entrevista

Mostra-te entusiasmado com inovaÃ§Ã£o tecnolÃ³gica, automaÃ§Ã£o, geraÃ§Ã£o de cÃ³digo/modelagem â€” esses sÃ£o â€œsell-pointsâ€ da Quidgest.

Exemplo: â€œVi que a plataforma Genio permite acelerar muito o desenvolvimento usando modelagem â€” e estou interessado em como isto se aplica em soluÃ§Ãµes de RH, onde hÃ¡ muitos processos repetitivos e bastante lÃ³gica de negÃ³cioâ€.

Usa exemplos da tua experiÃªncia onde tiveste de modularizar cÃ³digo, reutilizar componentes, pensar em manutenÃ§Ã£o ou escalabilidade.

Pergunta ao CTO: â€œComo Ã© que integram vocÃªs novas funcionalidades de RH (por exemplo gamificaÃ§Ã£o de desempenho) na plataforma existente?â€ ou â€œQual Ã© o maior desafio tÃ©cnico que a equipa de RH enfrenta neste momento, em termos de dados ou de workflow?â€

Prepara-te para demonstrar que sabes trabalhar em equipa, comunicar bem com stakeholders de negÃ³cio (RH, recrutamento) e traduzir requisitos de negÃ³cio em soluÃ§Ãµes tÃ©cnicas â€” algo que encaixa bem no perfil da empresa.

Parte 2 â€“ Exemplos de exercÃ­cios de programaÃ§Ã£o/lÃ³gica adaptados Ã  Ã¡rea de RH/recrutamento/gestÃ£o de desempenho

Aqui vÃ£o alguns exercÃ­cios que podes praticar, adaptados ao contexto da vaga â€” depois segue-se cada exercÃ­cio com uma indicaÃ§Ã£o de como o podes resolver. Idealmente resolves em C# ou Java (ou outra linguagem de preferÃªncia suportada pela empresa) para treinar.

ExercÃ­cio 1: â€œMatch de Candidatos a Vagasâ€

DescriÃ§Ã£o: Tens um conjunto de candidatos e um conjunto de vagas. Cada candidato tem um conjunto de competÃªncias (strings) e cada vaga tambÃ©m. Queremos encontrar para cada vaga os 3 candidatos â€œmelhoresâ€ em termos de nÃºmero de competÃªncias que coincidem.
Entrada: Lista de candidatos: cada candidato = (ID, nome, lista competÃªncias). Lista de vagas: cada vaga = (ID, tÃ­tulo, lista competÃªncias exigidas).
SaÃ­da: Para cada vaga, lista dos top 3 IDs de candidatos que mais competÃªncias tÃªm em comum com a vaga (ordenados decrescente por nÃºmero de competÃªncias em comum, e por ID em caso de empate).
Exemplo simples:

Candidatos:
1, Ana, [ "C#", "SQL", "Team-lead" ]
2, Bruno, [ "Java", "SQL", "React" ]
3, Carla, [ "C#", "React", "SQL" ]
4, Daniel, [ "C#", "SQL" ]

Vagas:
10, Desenvolvedor C#, [ "C#", "SQL" ]
11, Front-end React, [ "React", "CSS", "HTML" ]

SaÃ­da esperada:
Vaga10 -> [1,4,3]   (Ana tem 2 competÃªncias que coincidem, Daniel 2, Carla 2 â€” desempate por ID)
Vaga11 -> [3,2,1]   (Carla tem "React", Bruno tem "React", Ana tem nenhuma, logo Carla (1), Bruno (1), Ana (0) )


Como resolver:

Para cada vaga, percorre todos candidatos e calcula matchCount = nÃºmero de competÃªncias em comum (usar Set de competÃªncias para cada lado).

Armazena pares (candidateID, matchCount), ordena por matchCount desc, candidateID asc, e escolhe os top3.

Complexidade: se N candidatos, M vagas, K competÃªncias por candidato/vaga, complexidade ~O(NÂ·MÂ·K) que para tamanhos moderados estÃ¡ bem.

Em C#: podes usar HashSet<string> para competÃªncias, List<Tuple<int,int>> para resultados, Sort com custom comparer.

Pensa em casos de fronteira: menos de 3 candidatos, candidatos sem competÃªncias, vagas sem competÃªncias etc.

ExercÃ­cio 2: â€œHistÃ³rico de AvaliaÃ§Ãµes de Desempenhoâ€

DescriÃ§Ã£o: Tens registos de avaliaÃ§Ãµes de colaboradores: cada registo = (colaboradorID, dataAvaliaÃ§Ã£o, pontuaÃ§Ã£o [0â€“10]). Implementa uma funÃ§Ã£o que para cada colaborador devolve a tendÃªncia da avaliaÃ§Ã£o entre as Ãºltimas N avaliaÃ§Ãµes: â€œsubindoâ€, â€œestÃ¡velâ€ ou â€œdescendoâ€.
Entrada: Lista de avaliaÃ§Ãµes para mÃºltiplos colaboradores, e N (integer).
SaÃ­da: DicionÃ¡rio/Map de colaboradorID â†’ string (â€œsubindoâ€, â€œestÃ¡velâ€, â€œdescendoâ€).
Regra: Ordena as avaliaÃ§Ãµes de cada colaborador por data descrescente, pega nas Ãºltimas N pontuaÃ§Ãµes p1, p2, â€¦, pN (p1 mais recente). Se p1 > p2 > p3 > â€¦ (todas em sequÃªncia estrita), entÃ£o â€œsubindoâ€. Se p1 < p2 < p3 < â€¦, â€œdescendoâ€. Caso contrÃ¡rio, â€œestÃ¡velâ€. Se houver menos de N avaliaÃ§Ãµes, devolve â€œestÃ¡velâ€.
Como resolver:

Agrupa os registos por colaborador (por exemplo Dictionary<int,List<Avaliacao>> em C#).

Para cada colaborador: ordena as suas avaliaÃ§Ãµes por data descrescente, pega nas primeiras N se existirem, verifica a sequÃªncia.

Utiliza lÃ³gica simples de iteraÃ§Ã£o para ver se cada elemento Ã© maior que o prÃ³ximo (para â€œsubindoâ€), ou menor (para â€œdescendoâ€), ou se nÃ£o se encaixa â†’ â€œestÃ¡velâ€.

Testa casos: N = 1 (automaticamente â€œestÃ¡velâ€ pois nÃ£o hÃ¡ sequÃªncia), igual pontuaÃ§Ãµes (ex: 7,7,7) â†’ â€œestÃ¡velâ€.

ExercÃ­cio 3: â€œOrganograma de RH / Hierarquia de Colaboradoresâ€

DescriÃ§Ã£o: Na gestÃ£o de desempenho, hÃ¡ frequentemente uma estrutura hierÃ¡rquica (um gestor com vÃ¡rios subordinados, que por sua vez podem ter subordinados). Dado uma lista de relaÃ§Ãµes â€œgestorID â†’ colaboradorIDâ€, implementa duas funcionalidades:

FunÃ§Ã£o que, dado um colaboradorID, devolve o nÃ­vel hierÃ¡rquico desse colaborador (nÃ­vel 0 se for o topo, nÃ­vel 1 se reporta directamente ao topo, etc).

FunÃ§Ã£o que, dado um colaboradorID, devolve a lista de IDs de todos os colaboradores que estÃ£o abaixo desse colaborador na hierarquia (todos os subordinados directos e indirectos).
Entrada: Lista de pares (gestorID, colaboradorID), e depois queries para cada funÃ§Ã£o.
Como resolver:

ConstrÃ³i um grafo dirigido ou uma Dictionary<int,List<int>> onde para cada gestorID tens lista dos seus subordinados directos.

Para a funÃ§Ã£o 1: percorre â€œpara cimaâ€ (se tens tambÃ©m mapeamento colaborador â†’ gestor) atÃ© encontrares o topo (gestor que nÃ£o aparece como colaborador) contando nÃ­veis.

Para a funÃ§Ã£o 2: faz DFS ou BFS a partir do nÃ³ colaboradorID como raiz, e recolhe todos os nÃ³s alcanÃ§Ã¡veis.

Considera casos de ciclos (idealmente nÃ£o deveria haver, mas a funÃ§Ã£o poderia detectar e evitar loop infinito) ou colaboradores sem gestor (topo).

Complexidade: se nÃºmero de nodos = V e arestas = E, funÃ§Ã£o 2 tem O(V+E) no pior caso.

ExercÃ­cio 4: â€œPlaneamento de Entrevistas / Disponibilidadeâ€

DescriÃ§Ã£o: Uma equipa de recrutamento quer agendar entrevistas para candidatos com vÃ¡rios entrevistadores. Tens uma lista de colaboradores (entrevistadores) e a sua disponibilidade em dias/hora-blocos, e uma lista de candidatos que tÃªm tambÃ©m disponibilidade. Queremos atribuir cada candidato a um entrevistador num horÃ¡rio que funcione para ambos. Implementa uma funÃ§Ã£o simples que devolve um agendamento ou indica que nÃ£o foi possÃ­vel para algum candidato.
Entrada: Para cada entrevistador: colaboradorID + lista de horÃ¡rios disponÃ­veis (por ex â€œ2025-10-24 10:00â€“11:00â€, â€œ2025-10-24 14:00â€“15:00â€). Para cada candidato: candidatoID + lista de horÃ¡rios disponÃ­veis. Queremos produzir lista de (candidatoID, entrevistadorID, horÃ¡rio).
Como resolver:

Uma abordagem simples: para cada candidato da lista, percorre a lista de entrevistadores e tenta encontrar um horÃ¡rio disponÃ­vel que coincida entre eles. Se encontrar, marca o horÃ¡rio como ocupado para ambos e passa ao prÃ³ximo candidato.

Usa estruturas como Dictionary<entrevistadorID, HashSet<horario>> e Dictionary<candidatoID, HashSet<horario>>.

Ordena candidatos (talvez pelo nÃºmero de disponibilidades menor primeiro para optimizar).

Considera casos onde algum candidato nÃ£o encontra horÃ¡rio â†’ devolve â€œNÃ£o foi possÃ­vel agendar para todosâ€.

Pensa em melhorias: algoritmo de â€œmatching bipartidoâ€ entre candidatos e horarios+entrevistadores (se quiseres elevar o nÃ­vel tÃ©cnico).

Parte 3 â€“ Como podes conjugar os dois â€“ o â€œcompany + exercÃ­cio tÃ©cnicoâ€

Antes da entrevista, escolhe uma ou duas das tarefas de programaÃ§Ã£o acima e resolve-as ** na linguagem que vais usar** (C# ou Java). Comentando bem o teu raciocÃ­nio.

Durante a entrevista, ao te pedirem um exercÃ­cio â€œleveâ€, podes propor: â€œPosso usar como base um cenÃ¡rio de recrutamento/entrevistas, para ligar com o vosso domÃ­nio de RH.â€ Isto mostra alinhamento com o negÃ³cio da empresa (RH/recrutamento/gestÃ£o de desempenho).

Depois de escreveres o cÃ³digo, aproveita para discutir como se encaixaria no contexto da Quidgest: por exemplo, como modelarias isso na plataforma Genio, como as entidades seriam definidas, como evoluiria a funcionalidade, como garantiria manutenÃ§Ã£o.

Quando quiserem fazer perguntas de arquitectura ou design, pega num destes exercÃ­cios e pergunta: â€œSe fossemos escalar para 10 000 colaboradores, ou integrar com outros sistemas de HR, como o modificarias?â€ Mostra que pensas alÃ©m do cÃ³digo imediato.



âœ…O que os candidatos relatam

Um candidato para vaga de Software Engineer descreveu:

â€œentrevista normal para conhecer o percurso profissional e acadÃ©mico e termina com uma sÃ©rie de problemas tÃ©cnicos simples de SQL e C que deram para ser feitas em 15 minutos, basta preencher os espaÃ§os indicados, nÃ£o Ã© necessÃ¡rio fazer cÃ³digo de raÃ­z.â€ 
Glassdoor

Em geral, o processo de entrevista consta de: triagem inicial, seguido de uma ou vÃ¡rias entrevistas (virtuais ou presenciais) com gestor ou HR, e pode incluir teste de competÃªncias ou amostra de trabalho. 
Glassdoor
+1

No site de revisÃµes, nota-se que a â€œdificuldade das entrevistasâ€ Ã© relatada como mÃ©dia/relativamente leve: por exemplo, no Teamlyzer uma mÃ©dia de 44/100 para dificuldade. 
Teamlyzer

No anÃºncio de entrevistas no Glassdoor: o processo mÃ©dio foi descrito como â€œmuito fÃ¡cil e relaxadoâ€ por um candidato de estÃ¡gio/trabalho leve. 
Glassdoor

ğŸ¯ O que podes inferir / preparar com base nesses relatos

Espera questÃµes tÃ©cnicas relativamente simples ou moderadas: no relato, problemas de SQL e C que eram â€œpreencher espaÃ§osâ€ ou completar cÃ³digo em parte. Logo, nÃ£o necessariamente um desafio algoritmico ultra-complexo.

Certamente serÃ¡ valorizado que consigas comunicar o teu background profissional e acadÃ©mico de forma clara â€” houve candidatos que disseram que a parte â€œquem Ã©s / o que fizesteâ€ foi grande parte da entrevista.

Como vais entrevistar com o CTO da Ã¡rea de software de RH/recrutamento/gestÃ£o de desempenho, prepara-te para combinar essas competÃªncias tÃ©cnicas com domÃ­nio da lÃ³gica de negÃ³cio (RH, recrutamento, desempenho) e perguntas â€œporquÃª quiseres esta empresa / este papelâ€.

Apesar de relatos de â€œrelaxaâ€ ou â€œleveâ€, prepara-te para que tambÃ©m possam avaliar qualidade do cÃ³digo, clareza de pensamento, capacidade de modelagem ou abstraÃ§Ã£o â€” especialmente dada a natureza da Quidgest (plataforma de geraÃ§Ã£o automÃ¡tica de cÃ³digo) e o papel tÃ©cnico para RH.

Mesmo que os problemas tÃ©cnicos sejam â€œsimplesâ€, pratica algoritmos e SQL para estar a postos â€” e prepara-te para fazer â€œcompleta o cÃ³digoâ€, â€œcorrige este queryâ€, â€œexplique este fragmentoâ€.
